---
name: component-level-data-fetching
routeTemplate: ./data/component-templates/article.yml
title: Component-level data fetching
---
# Component-level data fetching

Next.js provides ability to pre-render pages at build time using [getStaticProps](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation) or you can pre-render page on each request using [getServerSideProps](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering). Expected that you will fetch all required data in `getStaticProps/getServerSideProps`.
We provide ability to do it using [SitecorePagePropsFactory](/docs/nextjs/data-fetching/data-services).

So, we can pre-render pages with data fetched on the page level. What if we want to fetch component specific data on component level? Our sample provides a simple way to do it. `SitecorePagePropsFactory` is using `ComponentPropsService`.

Let's dive in details how `ComponentPropsService` is doing this magick.

`ComponentPropsService` accepts next parameters:
* componentModule - function which returns Next.js component using `componentName`. You can find it in `temp/componentFactory` (generated by `scripts/bootstrap.ts`).
* layoutData - layout service data for your page.
* context - SSG/SSR Next.js context.

`ComponentPropsService` go through layout service data and take all renderings. In order to understand which component contains side-effects, our service takes `rendering.componentName` and uses it with `componentModule`.
Component contains side-effect and it will be called in `ComponentPropsService` in case:
* If we are in `SSR` mode it will look for exported `getServerSideProps` function.
* If we are in `SSG` mode it will look for exported `getStaticProps` function.
After finishing to execute all side-effects, it will store all the data in storage using format `{ [rendering.uid]: data }`.

Let's imagine that our page contains rendering, for example it's `ContentBlock` component.

We can edit `src/components/ContentBlock.tsx` and add side effects in order to fetch post which we want to render.
`useComponentProps` helps us get access to fetched data using `rendering.uid`.

```tsx
import {
  Text,
  RichText,
  Field,
  GetServerSideComponentProps,
  GetStaticComponentProps,
  useComponentProps,
  ComponentRendering,
} from '@sitecore-jss/sitecore-jss-nextjs';

type PostEntity = {
  title: string;
  body: string;
};

type ContentBlockProps = {
  rendering: ComponentRendering;
  fields: {
    heading: Field<string>;
    content: Field<string>;
  };
};

const ContentBlock = ({ fields, rendering }: ContentBlockProps): JSX.Element => {
  const externalData = rendering.uid ? useComponentProps<PostEntity>(rendering.uid) : undefined;

  return (
    <>
      <Text tag="h2" className="display-4" field={fields.heading} />

      <RichText className="contentDescription" field={fields.content} />

      {externalData && (
        <div>
          <h1>{externalData?.title}</h1>
          <p>{externalData?.body}</p>
        </div>
      )}
    </>
  );
};

const fetchPost = () =>
  fetch('https://jsonplaceholder.typicode.com/posts/1').then((res) => res.json());

export const getStaticProps: GetStaticComponentProps = async (rendering, layoutData, context) => {
  const post = await fetchPost();

  return post;
};

export const getServerSideProps: GetServerSideComponentProps = async (rendering, layoutData) => {
  const post = await fetchPost();

  return post;
};

export default ContentBlock;
```
